---
id: "2023-10-02-list_en"
title: "[OpenAI article] 
  Cloud Functions pro tips: Building idempotent functions | Google Cloud Blog

by Slawomir Walkowski, cloud.google.com • [See original](https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-building-idempotent-functions?hl=en)

##### Slawomir Walkowski

Software Engineer

In a previous blog post we discussed [how to use retries to make your serverless system resilient](https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-using-retries-to-build-reliable-serverless-systems) to transient failures. What we didn’t mention is that if you’re going to retry a function, it needs to be able to run more than once without producing unexpected results or side effects.

In computer science, this refers to the notion of [idempotence](https://en.wikipedia.org/wiki/Idempotence), meaning that operation results remain unchanged when an operation is applied more than once. Likewise, a function is considered idempotent if an event results in the desired outcome even if the function is invoked multiple times for a given event. In other words, if you want your functions to behave correctly upon retries, you have to make them idempotent. In this post, we’ll show you how to do that.

### Exploring idempotent functions

To better understand idempotency, let’s analyze a workflow. In this example, we have a function that processes incoming data, writes the results to one storage system, and then to another one.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/1_TJuTVwD.max-400x400.png](https://proxy-prod.omnivore-image-cache.app/0x0,swe5tBW2Qc9sZNm_jFU9ORYZzEzQcgDPC82G-ORA64FM/https://storage.googleapis.com/gweb-cloudblog-publish/images/1_TJuTVwD.max-400x400.png)

Success scenario: a write sequence to two different datastores

The problem arises when, as you may expect, an upload to one of the storage systems fails. For example, imagine the second upload fails; this can result in data loss or inconsistency.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/2_YQk7fzY.max-400x400.png](https://proxy-prod.omnivore-image-cache.app/0x0,sLTwOPH7SJ-pKqYwUU9Fs3V5gMnPqcD1JyRL_PO-HsR4/https://storage.googleapis.com/gweb-cloudblog-publish/images/2_YQk7fzY.max-400x400.png)

Error scenario: the write to the second datastore fails

We already know how to handle such a failure—apply retries. But is it always safe to apply a retry? In this example, executing the function a second time stores the output in the second storage system (if the upload succeeded) but also results in writing a duplicate record or object into the first storage system. This could be unexpected by other systems, and result in further problems. Let’s discuss how to prepare a function for retried executions to avoid this kind of data duplication.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/3_F8C8CQD.max-500x500.png](https://proxy-prod.omnivore-image-cache.app/0x0,s_rkQ8-za_HXJ_eDzaSnVDQ2Fz1w1O2VwQAG1guE34XQ/https://storage.googleapis.com/gweb-cloudblog-publish/images/3_F8C8CQD.max-500x500.png)

Here, retrying your function may introduce a duplicate record.

First, let’s look at a non-idempotent background function. It performs two uploads—first, it adds a document to Cloud Firestore, our flexible, scalable NoSQL database, and then uploads the document to another storage system off GCP. In a possible scenario when the upload to Cloud Firestore succeeds but the second upload fails, retrying the function results in a duplicate document, with the same contents, in the Cloud Firestore database. Of course, we don’t want duplicates, as they could cause confusion, accounting problems, and further inconsistencies.

**Use your event IDs**

One way to fix this is to use the event ID, a number that uniquely identifies an event that triggers a background function, and— this is important—remains unchanged across function retries for the same event.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/4_g8cS8fa.max-500x500.png](https://proxy-prod.omnivore-image-cache.app/0x0,spmDNYd7hhcUONr6dzegTLwOjeC4ufFR5DUsPpRMZyWQ/https://storage.googleapis.com/gweb-cloudblog-publish/images/4_g8cS8fa.max-500x500.png)

Use event identifiers to avoid unwanted side-effects such as duplication

To use an event ID to solve the duplicates problem, the first thing is to extract it from the event context that is accessed through [function parameters](https://cloud.google.com/functions/docs/writing/background#function_parameters). Then, we utilize the event ID as a document ID and write the document contents to Cloud Firestore. This way, a retried function execution doesn’t create a new document, just overrides the existing one with the same content. Similarly, some external APIs (e.g., [Stripe](https://stripe.com/blog/idempotency)) accept an idempotency key to prevent data or work duplication. If you depend on such an API, simply provide the event ID as your idempotency key.

There! Now that you’ve applied this event ID mechanism, you shouldn’t see any more duplicates—in Cloud Firestore, or in another system that accepts idempotency keys.

But what if the system you call does not support idempotency? Consider the following example. Here, we call Sendgrid, the email delivery service, to send an email from the function. But the call isn’t idempotent so retrying the function may result in duplicate emails. What can you do to avoid this problem?

The general solution here is note when a system has handled an event, by recording its event ID. This way, you reduce the chance of unwanted retried calls to other services. In this example, we record the event ID in Cloud Firestore, but you can use another database or storage system as well. On each function execution, check whether the given event has already been recorded. If not, run the code and store the event ID in Cloud Firestore.

**A new lease on retries**

While this approach eliminates the vast majority of duplicated calls on function retries, there’s a small chance that two retried executions running in parallel could execute the critical section more than once. To all but eliminate this problem, you can use a lease mechanism, which lets you exclusively execute the non-idempotent section of the function for a specific amount of time. In this example, the first execution attempt gets the lease, but the second attempt is rejected because the lease is still held by the first attempt. Finally, a third attempt after the first one fails re-takes the lease and successfully processes the event.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/5_vIxFumt.max-600x600.png](https://proxy-prod.omnivore-image-cache.app/0x0,s7xJOl6BDCJJ8CeRzLSRArQBtiULbwtK-Ztukqr5lk70/https://storage.googleapis.com/gweb-cloudblog-publish/images/5_vIxFumt.max-600x600.png)

Using a lease mechanism to handle non-idempotent code

To apply this approach to your code, simply run a Cloud Firestore transaction before you send your email, checking to see if the event has been handled, but also storing the time until which the current execution attempt has exclusive rights to sending the email. Other concurrent execution attempts will be rejected until the lease expires, eliminating all duplicates for all intents and purposes.

By now, you can see that there are multiple ways to make a function idempotent, and doing so is an important part of handling failures and improving the reliability of your system. First, you can ensure that mutations can happen more than once without changing the outcome. You can also record event IDs that have been processed, query database state in a transaction before mutating the state, and supply an idempotency key if you’re calling APIs that support them. To learn more, check out [cloud.google.com/functions/](https://cloud.google.com/functions/) and you can also find all the code we used in this blog post on [GitHub](https://github.com/GoogleCloudPlatform/cloud-functions-reliability-nodejs/tree/master/idempotency). Stay tuned for the next post in the series, where we’ll demonstrate how to use retries and idempotency as part of a simple restaurant order-processing system.

Posted in

-   [Serverless](https://cloud.google.com/blog/products/serverless)
-   [Application Development](https://cloud.google.com/blog/products/application-development)
-   [Google Cloud](https://cloud.google.com/blog/products/gcp)
  "
description: "First view on 
  Cloud Functions pro tips: Building idempotent functions | Google Cloud Blog

by Slawomir Walkowski, cloud.google.com • [See original](https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-building-idempotent-functions?hl=en)

##### Slawomir Walkowski

Software Engineer

In a previous blog post we discussed [how to use retries to make your serverless system resilient](https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-using-retries-to-build-reliable-serverless-systems) to transient failures. What we didn’t mention is that if you’re going to retry a function, it needs to be able to run more than once without producing unexpected results or side effects.

In computer science, this refers to the notion of [idempotence](https://en.wikipedia.org/wiki/Idempotence), meaning that operation results remain unchanged when an operation is applied more than once. Likewise, a function is considered idempotent if an event results in the desired outcome even if the function is invoked multiple times for a given event. In other words, if you want your functions to behave correctly upon retries, you have to make them idempotent. In this post, we’ll show you how to do that.

### Exploring idempotent functions

To better understand idempotency, let’s analyze a workflow. In this example, we have a function that processes incoming data, writes the results to one storage system, and then to another one.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/1_TJuTVwD.max-400x400.png](https://proxy-prod.omnivore-image-cache.app/0x0,swe5tBW2Qc9sZNm_jFU9ORYZzEzQcgDPC82G-ORA64FM/https://storage.googleapis.com/gweb-cloudblog-publish/images/1_TJuTVwD.max-400x400.png)

Success scenario: a write sequence to two different datastores

The problem arises when, as you may expect, an upload to one of the storage systems fails. For example, imagine the second upload fails; this can result in data loss or inconsistency.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/2_YQk7fzY.max-400x400.png](https://proxy-prod.omnivore-image-cache.app/0x0,sLTwOPH7SJ-pKqYwUU9Fs3V5gMnPqcD1JyRL_PO-HsR4/https://storage.googleapis.com/gweb-cloudblog-publish/images/2_YQk7fzY.max-400x400.png)

Error scenario: the write to the second datastore fails

We already know how to handle such a failure—apply retries. But is it always safe to apply a retry? In this example, executing the function a second time stores the output in the second storage system (if the upload succeeded) but also results in writing a duplicate record or object into the first storage system. This could be unexpected by other systems, and result in further problems. Let’s discuss how to prepare a function for retried executions to avoid this kind of data duplication.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/3_F8C8CQD.max-500x500.png](https://proxy-prod.omnivore-image-cache.app/0x0,s_rkQ8-za_HXJ_eDzaSnVDQ2Fz1w1O2VwQAG1guE34XQ/https://storage.googleapis.com/gweb-cloudblog-publish/images/3_F8C8CQD.max-500x500.png)

Here, retrying your function may introduce a duplicate record.

First, let’s look at a non-idempotent background function. It performs two uploads—first, it adds a document to Cloud Firestore, our flexible, scalable NoSQL database, and then uploads the document to another storage system off GCP. In a possible scenario when the upload to Cloud Firestore succeeds but the second upload fails, retrying the function results in a duplicate document, with the same contents, in the Cloud Firestore database. Of course, we don’t want duplicates, as they could cause confusion, accounting problems, and further inconsistencies.

**Use your event IDs**

One way to fix this is to use the event ID, a number that uniquely identifies an event that triggers a background function, and— this is important—remains unchanged across function retries for the same event.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/4_g8cS8fa.max-500x500.png](https://proxy-prod.omnivore-image-cache.app/0x0,spmDNYd7hhcUONr6dzegTLwOjeC4ufFR5DUsPpRMZyWQ/https://storage.googleapis.com/gweb-cloudblog-publish/images/4_g8cS8fa.max-500x500.png)

Use event identifiers to avoid unwanted side-effects such as duplication

To use an event ID to solve the duplicates problem, the first thing is to extract it from the event context that is accessed through [function parameters](https://cloud.google.com/functions/docs/writing/background#function_parameters). Then, we utilize the event ID as a document ID and write the document contents to Cloud Firestore. This way, a retried function execution doesn’t create a new document, just overrides the existing one with the same content. Similarly, some external APIs (e.g., [Stripe](https://stripe.com/blog/idempotency)) accept an idempotency key to prevent data or work duplication. If you depend on such an API, simply provide the event ID as your idempotency key.

There! Now that you’ve applied this event ID mechanism, you shouldn’t see any more duplicates—in Cloud Firestore, or in another system that accepts idempotency keys.

But what if the system you call does not support idempotency? Consider the following example. Here, we call Sendgrid, the email delivery service, to send an email from the function. But the call isn’t idempotent so retrying the function may result in duplicate emails. What can you do to avoid this problem?

The general solution here is note when a system has handled an event, by recording its event ID. This way, you reduce the chance of unwanted retried calls to other services. In this example, we record the event ID in Cloud Firestore, but you can use another database or storage system as well. On each function execution, check whether the given event has already been recorded. If not, run the code and store the event ID in Cloud Firestore.

**A new lease on retries**

While this approach eliminates the vast majority of duplicated calls on function retries, there’s a small chance that two retried executions running in parallel could execute the critical section more than once. To all but eliminate this problem, you can use a lease mechanism, which lets you exclusively execute the non-idempotent section of the function for a specific amount of time. In this example, the first execution attempt gets the lease, but the second attempt is rejected because the lease is still held by the first attempt. Finally, a third attempt after the first one fails re-takes the lease and successfully processes the event.

![https://storage.googleapis.com/gweb-cloudblog-publish/images/5_vIxFumt.max-600x600.png](https://proxy-prod.omnivore-image-cache.app/0x0,s7xJOl6BDCJJ8CeRzLSRArQBtiULbwtK-Ztukqr5lk70/https://storage.googleapis.com/gweb-cloudblog-publish/images/5_vIxFumt.max-600x600.png)

Using a lease mechanism to handle non-idempotent code

To apply this approach to your code, simply run a Cloud Firestore transaction before you send your email, checking to see if the event has been handled, but also storing the time until which the current execution attempt has exclusive rights to sending the email. Other concurrent execution attempts will be rejected until the lease expires, eliminating all duplicates for all intents and purposes.

By now, you can see that there are multiple ways to make a function idempotent, and doing so is an important part of handling failures and improving the reliability of your system. First, you can ensure that mutations can happen more than once without changing the outcome. You can also record event IDs that have been processed, query database state in a transaction before mutating the state, and supply an idempotency key if you’re calling APIs that support them. To learn more, check out [cloud.google.com/functions/](https://cloud.google.com/functions/) and you can also find all the code we used in this blog post on [GitHub](https://github.com/GoogleCloudPlatform/cloud-functions-reliability-nodejs/tree/master/idempotency). Stay tuned for the next post in the series, where we’ll demonstrate how to use retries and idempotency as part of a simple restaurant order-processing system.

Posted in

-   [Serverless](https://cloud.google.com/blog/products/serverless)
-   [Application Development](https://cloud.google.com/blog/products/application-development)
-   [Google Cloud](https://cloud.google.com/blog/products/gcp)
  , generated by OpenAI"
date: 2023-10-02
lang: en
published: false
relateTo:
  - 2023-10-02-list_fr
---

**`This article is part of a comprehensive automation program to automatically and programmatically post daily articles on development architecture, using OpenAI.`**

<article>

## Building Idempotent Functions: Master tips for Cloud Functions

##### By Arnaud Joye

Let's revive an old but significant subject, transcribed in a blog by [Slawomir Walkowski](https://cloud.google.com/blog/products/serverless/cloud-functions-pro-tips-building-idempotent-functions?hl=en), a Software Engineer at Google Cloud. In this post, we delve into building idempotent functions to enhance the resiliency of your serverless systems.

#### Unveiling Idempotent Functions

In computer science, idempotence guarantees that a function will yield consistent results - no matter how many times you execute it. When executing a function multiple times for a specific event, the resulting outcome stays the same, only then do we say the function is idempotent. 

The crux of idempotent functions lies in the retry aspect. When a function fails, we might need to retry it to ensure correct behavior. However, the challenge appears if the re-execution generates undesired results or side effects. This is where building the function to be idempotent saves the day. 

Let's clarify this idea with an example, a simple data processing function that writes results to two separate storage systems. Do you anticipate the problem here? What if the upload fails in one of the storages? As a quick solution, you may retry the function. It will certainly save the data to the second storage system (provided the upload is successful), but it will also duplicate the record into the first storage system, leading to potential inconsistencies. 

![Workflow](https://storage.googleapis.com/gweb-cloudblog-publish/images/1_TJuTVwD.max-400x400.png)

How do we circumvent this? Let’s dive deeper.

### Craft Your Function with Idempotency

How about we tweak a non-idempotent function into an idempotent one? Let’s take an instance where a document is first added to Cloud Firestore and then uploaded to a separate storage system. If the upload to Cloud Firestore turns successful, but the second upload fails, retrying just doubles the same document into the Cloud Firestore. This is what we intend to avoid. 

![Duplicated Record](https://storage.googleapis.com/gweb-cloudblog-publish/images/3_F8C8CQD.max-500x500.png)

**Embrace your Event IDs** 

A viable solution to this dilemma is using the Event ID - which uniquely identifies an event that triggers a background function. Upon using the Event ID as a document ID, and by writing document contents to Cloud Firestore, we ensure the idempotent functionality of our data storage and uploads. In simpler terms, a retried function execution doesn't add a new document, but instead, overrides the existing one with the same content. So, it prevents data duplication or leftover work. To follow this principle, you can provide the Event ID as your idempotency key in some particular APIs (e.g., [Stripe](https://stripe.com/blog/idempotency)). 

![Event ID](https://storage.googleapis.com/gweb-cloudblog-publish/images/4_g8cS8fa.max-500x500.png)

**Dealing with Non-idempotent Systems**

Now, what if the system you are working with doesn’t support idempotency? Consider the SendGrid email delivery service. A retried function here could lead to duplicate emails. To counter this, you can mark the handled events by recording their Event ID. This significantly reduces the chance of unanticipated retried calls to other services.

![Recording Event ID](https://storage.googleapis.com/gweb-cloudblog-publish/images/5_vIxFumt.max-600x600.png)

**Incorporating the Lease Mechanism**

Though the approaches mentioned above eliminate the majority of duplicated calls on function retries, there's a fringe chance of parallel retried executions happening more than once. Using a lease mechanism is a good practice here. When worked strategically, this mechanism let you carry out the non-idempotent section of the function exclusively for a specific duration. 

Therefore, while designing your serverless architecture, ensuring idempotency can drastically increase the reliability of your setups. As we have seen, several ways from using Event IDs to operate a lease mechanism can help achieve idempotency. If you're willing to go further, you can check [cloud.google.com/functions/](https://cloud.google.com/functions/) and the code used in the [GitHub](https://github.com/GoogleCloudPlatform/cloud-functions-reliability-nodejs/tree/master/idempotency).

So, heed these tips and tricks, and make your serverless systems more resilient and foolproof.

Posted in
- [Serverless](https://cloud.google.com/blog/products/serverless)
- [Application Development](https://cloud.google.com/blog/products/application-development)
- [Google Cloud](https://cloud.google.com/blog/products/gcp)


</article>